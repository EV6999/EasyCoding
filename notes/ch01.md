## 第一章 计算机基础

![大纲](./CH01-guideline.png)

----

### 1. 二进制
整数

* 二进制表示 <br />
  二进制即逢二进一，在电路板中用高低电平来表示0，1 <br />
  1条电路只能表示两种状态：0 或 1，故1条电路最多只能表示2个数字，范围是十进制的0..1 <br/>
  2条电路可以表示4 (2的2次方) 种状态：00, 01, 10, 11. 故2条电路最多可以表示4个数字，范围是十进制的0..3 (0 到 2^2-1) <br />
  8条电路可以表示256 (2的8次方) 种状态，故8条电路最多可以表示256个数字，范围是十进制的0..255 (0 到 2^8-1) <br />
  8条电路在计算机中表示8 bits. 8 bits = 1 Byte<br />
  Java中byte 类型变量占1个字节 (1 Byte = 8 bits), 表示的范围是从 -128..127 <br />
  
  *Q1： 刚才说到8条电路就是8 bits，他的范围是0..255，那byte也是8 bits，为什么他的范围不是 0..255，反而是-128..127？* <br />
  A1: 
  - 因为负数本身是一个很常见的情况，那对于8条电路来说，怎么表示负数呢？
  - 8条电路, 我们规定最左侧的一条表示正负，0表示正数，1表示负数。这条电路不参与数值表示。
  - 那么8条电路的最大值就是： 0-1111111 (1个0表示正数，7个1表示数值)。7个1所代表的最大数值是 +127
  - 那么8条电路的最小值就是： 1-1111111 (1个1表示负数，7个1表示数值)。7个1所代表的最小数值是 -127
  - 你可能会问，这个范围不是 -127..127 吗？-128怎么来的？
  - 在Java中，数字都是以补码的形式存储的。正数的补码和他的原码、反码是一样的；负数的补码等于他的反码+1；
  - 127的原码反码补码为 0111-1111.
  - -128补码的计算方式为，取出128的原码1000-0000，逐位取反得到0111-1111，加1之后又变为了 1000-0000
  - 因为所有的数字都是以补码形式存在，那么当计算机看到1000-0000的时候，他就是指-128, 而不是128.
  - 128的二进制是1000-0000，这个是不能用8 bits来表示的，因为他跟-128会发生歧义。
  - [这里有具体的解释](https://stackoverflow.com/questions/3621067/why-is-the-range-of-bytes-128-to-127-in-java)
  
  
* 原码 反码 补码 <br />
正数的补码和他的原码、反码是一样的；负数的补码等于他的反码+1；<br />
举例来说：35的原码、反码、补码是：0010-0011 <br/>
-35<br />
原码是：1010-0011<br />
反码是：1101-1100<br />
补码是：1101-1101<br />

-35的补码的另外一个解法：求得35的原码，逐位取反，然后加1，得到跟上面的结果是一样的。

* 加减运算

计算机内部用补码存储的一个好处就是，减法也可以用补码的加法来实现。比如

```
  00100011 --> 35
+ 11011011 --> -37 (补码)
----------
  11111110 --> -2 (补码)
```

* 位移运算

带符号位移 << >> <br />
带符号位移表示符号位参与移动。这种情况下，只有负数右移的情况高位补1，其他情况（包括正数左移、右移；负数的左移）都是空位补0 <br />
负数右移：因为负数的最高位是符号位，用1表示负数。当右移之后，应该保持符号位不变。<br />
右移: -35 右移1位: 1101-1101 >> 1 = 1110-1110 (补码), 再取补码得到: 1001-0010 = -18 (近似除以2) <br />
正数右移: 35. 0010-0011 >> 1 = 0001-0001 = 17 (近似除以2) <br />

其他情况比如: 负数左移, -35 << 1 = -70. 他的计算过程如下:
-35 的补码是: 1101-1101 左移一位, 空位补0, 结果为: 1011-1010, 注意此处的结果为补码. 想得到他所表示的数字需要取反再加1(补码的补码等于原码)
1011-1010 取反 = 1100-0101 加1 = 1100-0110 = -70. <br />

正数左移: 35左移1位: 0010-0011 << 1 = 0100-0110 = 70. <br />
总体来说在不溢出的情况下,左移1位相当于乘以2; 右移1位近似除以2<br />
正数左移的结果可能是正数也可能是负数; 负数左移的结果可能是负数也可能是正数.<br />

比如byte 类型的 64左移一位: 0100-0000 << 1 = 1000-0000 = -128 (正数左移得到负数)<br/>
-96左移一位: 1010-0000 << 1 = 0100-0000 = 64 (负数左移得到正数)


无符号位移 >>> <br />
注意不存在 <<< 无符号左移. <br />
在无符号右移的情况下,符号位和正常的数字一样,一起参与移动. 无论是正数还是负数.高位直接补0. <br />
对于int(32位)来说,右移1位的结果等于右移33位的结果.也就是说右移的实际位数是 n%32. <br/>
同理,对于 long(64位) 来说, 右移1位等于右移65位,右移5位等于右移69位. 也就是说实际位数是 n%64 <br />



### 2. 浮点数

浮点数在计算机中的表示方法类似于数学中的科学计数法.
科学计数法的表示是 a x 10^n (aen). 也就是一个常数 乘以 10的 n 次方.

以32位浮点数为例,他在计算机中的表示方法如下:
32位即32bit

第一个 bit 表示符号位 <br />
紧接着后面 8 bit 表示指数(也就是 n 次方的 n) <br />
还剩下23 bit, 用来表示有效数字(也就是 科学计数法 中的 a) <br />

符号位, 1 为负数; 0 为正数.

8 bit的指数又叫做阶码. 他所能代表的范围不是 0..256(2^8), 而是 -126..127

其中23 bit 的有效数字可以全部为0, 这种情况代表有效数字为 1.0<br/>
1这个数字是默认存在的,这样的话用23bit 可以达到24个 bit 的效果.<br/>
也就是说如果23bit 全部为1的情况下等于二进制的1.111...11 (小数点后共23个1), 这是一个无限接近于2的值.<br/>

所以32bit 的浮点数,最大可以表示: 2*2^127. 2^127 ~= 1.7 X 10^38. 所以最大值即: 2 x 1.7 x 10^38.

* 浮点数表示实例:
-16 = 1/1000-0011/000..000(23个0)

```
1 - 代表负数

阶码: 1000-0011 - 这个二进制的10进制数值是131. 131 - 127 = 4. 也就是 2的4次方.

有效数字: 尾数部分等于0.

也就是1.0 x 2^4 = 16.
```

解释一下为什么`阶码`是131. 而不直接是4. <br/>
简单来说,当需要表示小数的时候需要用到2的负数次方. 所以`阶码`不能从0开始,而是从-126开始的.
127只是一个中点值. 任何数值的指数部分的值都要减去127得到真正的指数值,然后再求出2的指数次方.
这样的话2的-1次方就可以得到一个0.5的值.当用1.0*0.5的时候就得到了一个浮点数.

详细一点来说的话就是,阶码的表示方法实际上是用移码表示的. 
所谓移码就是把一个数值映射到正数域,其特点是可以直观的反映两个真值的大小,对计算机来说不用考虑负号的问题.

[TBC-1] 此处需要解释的更详细.


* 加减运算

	- 零值检测
	- 对阶操作
	- 尾数求和
	- 结果规格化
	- 结果舍入
[TBC-2] 需要加一个实例来解释对每个步骤的说明

### 3. 字符集与乱码

* ASCII
	
	起初计算机为用0-1信号表示不同的字符,先考虑到的是英文的26个字符大写和小写加上0-9这10个数字,这样就至少有62个字符,除此之外还有一些特殊字符,比如~!@#这样的,加起来一定是超过了64个(我想键盘上的英文字母加数字加上特殊字符一共也不会超过127个). 这里提到了超过64是因为64这个数字是2的6次方.6次方即为6bit. 如果超过了6bit 所能表示的范围,那么至少是需要7个 bit 来表示这些字符的.<br/>
	再加上一个奇偶校验位,所以最后决定用8bit 来表示一个字符.这就是1Byte = 8bit 的由来.也就是 ASCII.
	
	
* 汉字
	
	当计算机在中国设计的时候肯定需要用到汉字.而汉字的数量众多,用1Byte (8个 bit 才能表示127个字符)肯定是不够的,那么肯定得扩展.所以就在 ASCII 的基础上进行扩展,保持对 ASCII 的兼容.<br/>
	一个字节只能表示128个字符,所以汉字需要采用双字节进行编码(双字节就是2Byte,他可以表示65535个字符,现在汉字数量是91251个,很明显不够对吧?这是在GB2312中收录了 6763 个常用汉字, GBK (k == kuo 是扩展的意思) 在GB2312基础上进行了扩展,支持繁体字).<br/>
	ASCII 码其实就是一种字符编码约定.比如约定 ASCII=65 就是表示A. 97就是表示 a,这是规定好的.这个也就是我们常常会去查阅的 ASCII 码表. <br/>
	类似的汉字的编码表在保留了前128个 ASCII 之外增加了其他的数字与汉字的映射关系.也就是说无论是GBK \ GB2312 还是 Unicode \ UTF-8 \ UTF-16 分别规定了自己的码表,确定了该编码方式能表示的字符(不仅仅是汉字还有其他非英文国家的字符). 
	
* 乱码是怎么回事

	当我们保存文字到记事本或者数据库的时候(其实都是保存到了磁盘),都需要为记事本或者数据库指定一个编码方式,当以指定的编码方式保存之后就要用与这个编码方式兼容的编码来读取;否则就会出现乱码.<br/>
	举个例子来说, 假设 22909 用 Unicode 编码是 '好' 这个字, 并且存到了记事本中, 如果我们用非 Unicode 编码来读取这个文件,恰好这个编码方式与 Unicode 不兼容的话,显示出来的就是乱码.
	
	
### 3. TCP/IP

网络分层: <br />
1. 应用层 (典型协议: HTTP / SMTP)<br />
2. 传输层 (典型协议: TCP / UDP)<br />
3. 网络层 (典型协议: IP)<br />
4. 链路层 <br />

_程序在发送消息时, 是由应用层发起, 应用层按照既定的协议打包数据, 随后由传输层加上传输双方的端口号; 网络层加上双方的IP地址; 链路层加上双方的MAC地址. 并将数据拆分成数据帧, 经过多个路由器和网关之后到达目标机器_


* IP协议

IP协议的作用是把各种数据包传递给对方. 是无连接, 无状态的, 不能保证数据帧是否有序到达.<br />
IP报文在IP报头中有目标机器的IP地址. 并且在链路层会给将要发送的数据加上MAC地址.<br />
IP 协议使用 ARP (Address Resolution Protocol) 来查找到 MAC 地址对应的目标主机.<br />
ARP 协议的作用是根据IP地址查找MAC地址对应的主机. 他的工作流程类似于快递包裹的投递.<br />

-- *ARP协议的工作流程* <br />
_当我们要投递一个包裹给美国的朋友, 我们会把快递交给离我们最近的快递公司, 这个快递公司也许不负责国际业务, 但他会将这个包裹送到负责国际业务的相关公司进行中转, 这个包括到达国际业务部门时, 国际业务部门发现这个快递是送往美国的, 就会把这个快递送给负责美国业务的航空公司, 然后这个快递送到了美国之后, 再下发到具体的州/市/县, 最终送达到某小区的某户人家_ <br />

_类似的, 当我们通过互联网发送一个消息给位于美国的朋友, 我们的应用程序将数据打包之后发送给我们设备所连接的路由器, 路由器可能本身不知道目标地址的那个MAC对应的主机是哪一台, 路由器就把他交给他的上级节点, 他的上级节点如果通过IP地址找到了MAC地址对应的主机,则直接传递给那台主机;如果找不到目标主机就继续往上传递,直到那台能识别出IP地址所对应的 MAC地址的网络设备; 最后这台网络设备将数据传递给目标主机_<br />

- TTL IP报文中在 IP报头中有一个 TTL(8 bit) 属性. 该属性代表此报文的生存时间, 他是一个数字, 这个数字指定了该数据包所能记过的最多路由器总数. 当一个报文通过网络传递给另外一个主机时,通常这个过程不是一下就能传递到的,而是可能会经过多个物理网络才能到达目标主机. 每经过一个主机就将此数字减去1. 当该字段的值变为0时,数据包就会被丢弃. 并由最后一个路由器负责发送一个ICMP (Internet Control Message Protocal) 给源主机, 以避免源主机无休止的发送报文. 经常使用的 ping / telnet 就是基于 ICMP 的网络状态监测工具.
- MTU (Maximum Transmission Unit) 最大传输单元. 当数据包在不同的物理网络当中传递时,由于不同的硬件的特性不同,对数据帧的最大长度有不同的限制. 这个限制被称为最大传输单元. 那么不同的物理网之间就需要对数据进行分片,这个分片工作通常是由路由器完成的.

* TCP建立连接
	- TCP是面向连接的,确保数据在两台设备之间有序可靠到达的协议.
	- TCP报文头中包含了源主机的IP地址和端口号 以及 目标主机的IP地址和端口号, 这4个元素确定了唯一一条TCP连接.
	- TCP是区分服务端和客户端的. 在建立连接之前, 服务端先启动并监听某个端口, 客户端发起对服务器端的连接请求.
	- TCP连接的建立是通过客户端和服务器端的三次握手来达成的.

* 三次握手是什么?

	三次握手指的是建立连接的三个步骤:
	
	- 第一次握手: 客户端发送一个数据包, 将SYN置为1, 表示希望建立连接. 假设这个包的序列号是 x. <font color='#cc3300'>*_注意第一次握手完整的过程不仅仅是客户端发送连接请求这一步, 同时还包括, 服务端接收到客户端发来的信息_*</font>
	- 第二次握手: 服务端收到这个数据包, 看到SYN是1, 得知这个客户端是想要建立连接, 就发送数据包给客户端, 其中 SYN / ACK 都为1, 表示服务器端已经收到了连接请求, 并请求开始跟客户端进行通信(SYN位). 同时发送序列号 (y=x+1, 与ACK位配合) 给客户端 <font color='#cc3300'>*_注意第二次握手不仅仅是服务器端发送信息给客户端这一步,同时还包括, 客户端接收到服务端发来的信息_*</font>
	- 第三次握手: 客户端收到服务端的这个数据包后, 发送数据包给服务端, 其中 ACK 为1, 表示已经收到了服务器端的确认信息, 客户端已经准备好跟服务端通信了. 同时发送序列号 (y+1), 表示收到了服务端的SYNC请求. <font color='#cc3300'>*_注意第三次握手不仅仅是客户端发送消息给服务端,同时还包括, 服务器端接收到客户端发来的信息_*</font>
	

* 为什么TCP建立连接需要三次握手?

三次握手的主要目的有两个: *信息对等* 和 *防止超时*.

- 关于信息对等, 双方只有确定4类信息才能建立连接, 即双方都要确认: 自己发送数据的能力, 自己接收数据的能力, 对方发送数据的能力, 对方接收数据的能力.

| 第 N 次握手 | 客户端 - 自己发报能力 | 客户端 - 自己收报能力 | 客户端 - 对方发报能力 | 客户端 - 对方收报能力 | 服务端 - 自己发报能力 | 服务端 - 自己收报能力 | 服务端 - 对方发报能力 | 服务端 - 对方收报能力 |
| :------:| :------: | :------: | :------: | :------: | :------: | :------: | :------: | :------: |
| 第 1 次握手 | NO | NO | NO | NO | NO | <font color='#009900'>YES</font> | <font color='#009900'>YES</font> | NO |
| 第 2 次握手 | <font color='#009900'>YES</font> | <font color='#009900'>YES</font> | <font color='#009900'>YES</font> | <font color='#009900'>YES</font> | NO | <font color='#009900'>YES</font> | <font color='#009900'>YES</font> | NO |
| 第 3 次握手 | <font color='#009900'>YES</font> | <font color='#009900'>YES</font> | <font color='#009900'>YES</font> | <font color='#009900'>YES</font> | <font color='#009900'>YES</font> | <font color='#009900'>YES</font> | <font color='#009900'>YES</font> | <font color='#009900'>YES</font> |

- 关于防止请求超时导致脏连接

_通常网络报文的生存时间(TTL)要比TCP建立连接超时时间要长_

如果两次握手就能创建连接的话, 就可能会出现下面的情景.

```
客户端发送请求给服务器端
客户端 --SYN(1)--> 服务端
由于网络原因,TCP超时,但连接建立的请求报文的TTL较长所以还在网络上传输.
* --报文--还在网络上传输
* 但TCP已经发生了超时

所以客户端会收到通知,然后客户端就会重新发送连接请求
客户端 --SYN(2)--> 服务端
服务端 --SYN/ACK--> 客户端

* 如果两次握手就创建连接的话,此时客户端和服务端已经可以进行数据传输了

客户端 <--package--> 服务端
(双方进行数据传输)

传输完毕之后, 双方断开连接.
客户端 <-- XX --> 服务端

假设此时最开始的那个连接建立请求 SYN(1) 到达了服务端.
(如果两次握手就能创建连接的话), 服务端此时就会创建一个TCP连接, 并发送 SYN(1)/ACK(1) 给客户端.
客户端的状态因为不是SYN_SENT, 所以会直接丢弃服务端的这个报文,最终导致服务端产生了一个脏连接.

[TBC-3] 在这里插图
```

那么三次握手为什么就可以防止脏连接的出现呢?<br />
	<ol>
	<li>当服务器端收到SYN(1)这个请求时,也一样会处理,并发送SYN(1)/ACK(1)给客户端</li>
	<li>客户端收到这个报文之后,因为没有处在SYN_SENT状态,所以会直接丢弃这个消息,即:不会发送 ACK(1) 给服务端</li>
	<li>而服务端因为长时间没有收到客户端发来的ACK确认报文,最终超时而导致连接创建失败,因此不会出现脏连接的出现</li>
	</ol>


* TCP断开连接

TCP断开连接是通过 4 次挥手的过程来完成的. <br />
TCP 断开连接可以是任意一方发起.即 可以由客户端发起也可以由服务器端发起<br />

4次挥手是什么?

1. A机器想要断开连接, A 发送 FIN 信号给 B.<br />
2. B收到之后回复 A: ACK, 表示B已经收到了 A的断开请求, 只是现在还有数据没有发送完,所以现在还不能断开(此时 A 已经不能发送消息给 B了, A: FIN_WAIT_2)
3. B在将所有数据都发送给 A 之后,会发送 FIN/ACK 信号给 A,表示我的数据发送完了,现在可以断开了,只不过我在等你的确认消息. (B: CLOSE_WAIT)
4. A 回复 ACK 给 B, 代表A 现在要断开连接了.(A: TIME_WAIT)<br />
~~~~<br />

* 为什么需要4次挥手?

_当第4 步完成之后,A进入 TIME_WAIT状态. A会等待 2MSL(Maximum Segment Lifetype, 1MSL默认是 2 分钟), 如果在等待的时间内没有再收到 B 发送来的数据包,则断开连接; 如果 B 收到了 A发送过来的 ACK 消息,则断开连接_

如果第 4 步的消息由于网络原因无法正常送达 B机器, 则 B机器会认为是 A没有收到第三步他发送过去的 FIN/ACK 消息,那么 B 就会再次发送 FIN/ACK 给 A. A收到之后会再次发送 ACK 并重新计时; 

如果没有第四次挥手:
1. B 在第三步发送的 FIN/ACK 消息,A可能没有收到,则 A无法进入 CLOSED 状态
2. A 在收到 B发来的 FIN/ACK,并发送 ACK 之后立刻断开连接的话,则 B可能无法收到 A发来的 ACK, 则 B可能无法进入 CLOSED 状态.

### 4. HTTPS
	
